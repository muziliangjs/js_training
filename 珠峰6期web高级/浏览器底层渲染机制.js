/* 
  客户端（浏览器）：
   + DON TREE(dom树)：自上而下渲染完页面, 整理好整个页面的dom结构关系
   + CSSOM TREE（样式树）：当所有的样式资源，请求回来之后，按照引入css 的顺序依次渲染样式代码，生成样式树
   + RENDER TREE (渲染树)：把生成的dom树和cssom树合并在一起，生成渲染树，
   + layout 布局/回流/重拍：根据生成的渲染树，计算他们在设备视口 viewport 内的确切位置大小
   + 分层处理：按照层级定位分层处理，每个层级都有详细规划处具体的绘制步骤
   + painting： 按照每一个层级计算处理的绘制步骤，开始绘制页面


   前端性能优化 【CRP:关键渲染路径】
  + 生成DOM树 TREE
    + 减少DOM的层级嵌套
    + 不要使用”非标准“的标签
    + ...
  + 生成CSSOM
    + 尽可能不要使用@import(阻塞GUI渲染)
    + 如果CSS代码比较少，尽可能使用”style内嵌样式“（尤其是移动端开发）
    + 如果使用link，尽可能把所有的样式资源合并为一个css
      (减少HTTP请求数量，以及渲染CSSOM树的时候。也不需要计算依赖关系)
    + CSS选择器的链短一些，音乐css选择器渲染是从右到左的
    + 把link等导入css的操作放在HEAD中，目的是：一加载页面就开始请求资源，同时GUI去生成DOM树
    + ...

    对于其他资源的优化
      + 对于script 尽可能防止在页面底部，防止其阻塞GUI的渲染；对于部门<script>
        + async 是不管js的依赖关系的，哪个资源先获取到，就先把这个资源代码执行
        + defer 不会这样的，和link一样，是等待所有script defer都请求回来后，按照导入顺序/依赖关系依次渲染执行的
      + 对于 <img> 
        + 懒加载 第一次加载页面的时候不要加载图片，哪怕他是异步的，但是也占据了http并发数量，导致其他资源延后加载
        + 图片base64 不用请求加载图片。base64码基本上代表的就是图片，而且渲染速度也会很快（慎用，打爆事故在webpack工程化
        中可以使用。 因为它基于file-loader自动生成base64）

    Layout/painting 重要的优化手段（减少dom的回流和重绘）
      + 第一次加载页面必然会有一次回流和重绘
      + 触发回流操作后，也必然会触发重绘； 如果只是单纯的重绘，则不会引发回流；性能优化点，重点都在回流上；



  操作dom消耗性能? => DOM的回流
    + 元素在视口中的大小或者位置发生变化
    + 元素的删除或者新增（以及基于display控制显示隐藏）
    + 浏览器视口发生改变，
    + ... 
    这些操作浏览器都会重新计算每一个元素在视口中的位置和大小，也就是重新layout/reflow
    当代浏览器渲染队列机制
    
    // 避免回流： 总方式： 不要自己直接去操作DOM，例如VUE/REACT
    1.样式的”分离读写“:把修改样式的获取样式代码分离开
    
    2.新增元素

    3.把动画等频繁样式改变的操作，运用到position:fixed/avsolute...上 脱离文档流：单独一层
      + 利用分层机制，如果只改变一个层面上位置大小等信息，浏览器回流和重绘的速度会加快很多 

    4. 修改元素的 transform/opacity(filters)... 的这些样式，不会引发DOM的回流 ，浏览器的硬件加速，弊端就是消耗浏览器内存

     

*/
